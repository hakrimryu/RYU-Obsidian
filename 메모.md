데이터 이전 작업 메모

우선 데이터 이전 시에 무한하게 로딩이 표시 되는 에러가 있다.
이는 usercase를 미리 인젝트 하지 않고 데이터 이전을 하려고 했기 때문

-> 작업내용
TitleScreenPresenter.cs의 State호출 순서를 수정함.

Awake에서 RunLifeTimeScope().Forget();하여 LifetimeScope를 수동 실행함
암호화키 동기화 시작
동기화 성공시 스코프 빌드, test1 트루함

DidWindowPushEnter에서 State.Init 시작함.
바로 State.Wait 이동
State.Idle로 이동
State.Idle에 들어 오면 test2도 트루 해줌
여기서 test1과 test2가 모두 트루 라면 await Test() 시작함

Test()에서는 test1 = false; 로 해주고
State.Tap으로 이동시킴
탭이 활성화 되면 State.CheckMasterVersion을 시작하고 usecase들을 인젝트 시작함.

다운이 필요할 경우 State.AssetDownload 다운로드가 끝나면 다시 State.Idle로 돌아 간다.
이때 test1은 이미 false가 되어 있기 때문에 Test()는 실행하지 않기 때문에 State.Tap으로 이동하지 않고 계속 State.Idle에서 대기 한다.

이후 화면을 클릭하면 State.InputName으로 이동시키고
세이브 데이터의 유무에 따라 기존과 같이 진행 된다.

이것으로 화면 클릭 전에
암호화 동기화, 마스터 파일 확인및 다운로드, Scope빌드와 usecase인젝트를 끝마친다.


--------------------
코드의 목적과 실행 순서를 기반으로 하는 네이밍 추천은 다음과 같습니다:

1. **Test() 함수**:
    
    - 함수가 주로 하는 작업이 State.Tap으로의 이동과 test1을 false로 설정하는 것으로 보이므로, 해당 작업을 반영한 이름으로 바꾸는 것이 좋습니다.
    - 추천 이름: `InitializeTapState()`
2. **test1 변수**:
    
    - 이 변수는 Scope가 빌드되었는지와 `InitializeTapState()` 함수가 실행되었는지를 확인하는 데 사용됩니다. 따라서, 이를 반영한 의미 있는 이름이 필요합니다.
    - 추천 이름: `isScopeBuilt`
3. **test2 변수**:
    
    - 이 변수는 `State.Idle` 상태가 처음 진입되었는지를 확인하는 데 사용됩니다. 따라서, 이 상태에 진입했는지 여부를 나타내는 이름으로 바꾸는 것이 좋습니다.
    - 추천 이름: `hasEnteredIdleState`

코드의 가독성을 높이기 위해, 가능한 한 변수나 함수의 이름이 그 기능을 명확하게 나타내도록 하는 것이 좋습니다. 위의 제안된 이름들은 해당 코드의 동작을 반영하려고 제안된 것이므로, 실제 코드와 맞지 않는 부분이 있다면 조절해 사용하시기 바랍니다.

-------------------------------------

이외 이전 작업 추가 사항

이사를 하고 난 이후 w_encryption_key테이블에 user_id_num 기반의 암호화키(이전한 데이터 암호화 포함 SQLiteKey) 와 처음 게임을 시작하면 device_id기반으로 생성하는 데이터 두가지가 발생한다. 
이때 user_id_num을 사용한 데이터의 SQLiteKey를 이용하여 이전 데이터를 불러 올 수 있기 때문에 device_id를 이용한 데이터를 더이상 사용하지 않게 되어 쓰레기로 남아 있게 된다.

[클라]
DataTransferInputModalPresenter.cs에서 데이터 이전작업이 성공하는 타이밍에 
PlayerPrefs.SetString(PlayerPrefKeys.USER_ID, result.Item1.user_id);  
PlayerPrefs.SetString(PlayerPrefKeys.USER_ID_NUM, userIdNum.ToString());  
PlayerPrefs.SetString(PlayerPrefKeys.HAS_ACCOUNT, "true");
를 저장해 주고 이를 이용하여 게임 재기동 후 기존의 user_id_num기반 암호화키를 사용이 가능하다.
이후 await TEST(userIdNum);를 하여 남아 있는 device_id기반 암호화 데이터를 삭제 한다.

[서버]
데이터 이전 완료시 1회만 실행하는 API
delete_encryption_key_by_device_id api를 추가
파라미터로 deviceId와 userIdNum모두 받으며 w_encryption_key에서 해당 데이터를 검색하고
두 값이 모두 있다면 deviceId기반 암호화 데이터를 삭제 한다.
값을 삭제 하지 않아도 게임 플레이에는 아무런 지장을 주지 않기 때문에
본 api에서 에러가 발생하여도 클라(유저)는 알수 없으며 센트리에만 로깅한다.
또한 deviceId값이 없을 경우에도 정상이기 때문에 에러를 발생하지는 않는다.